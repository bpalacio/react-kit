import t,{friendlyDateTime as i}from"./datetime.js";import s from"./duration.js";import e from"./settings.js";import{InvalidArgumentError as r,InvalidIntervalError as n}from"./errors.js";import a from"./impl/invalid.js";import o from"./impl/formatter.js";import{DATE_SHORT as l}from"./impl/formats.js";const h="Invalid Interval";class u{constructor(t){this.s=t.start,this.e=t.end,this.invalid=t.invalid||null,this.isLuxonInterval=!0}static invalid(t,i=null){if(!t)throw new r("need to specify a reason the Interval is invalid");const s=t instanceof a?t:new a(t,i);if(e.throwOnInvalid)throw new n(s);return new u({invalid:s})}static fromDateTimes(t,s){const e=i(t),r=i(s),n=function(t,i){return t&&t.isValid?i&&i.isValid?i<t?u.invalid("end before start",`The end of an interval must be after its start, but you had start=${t.toISO()} and end=${i.toISO()}`):null:u.invalid("missing or invalid end"):u.invalid("missing or invalid start")}(e,r);return null==n?new u({start:e,end:r}):n}static after(t,e){const r=s.fromDurationLike(e),n=i(t);return u.fromDateTimes(n,n.plus(r))}static before(t,e){const r=s.fromDurationLike(e),n=i(t);return u.fromDateTimes(n.minus(r),n)}static fromISO(i,e){const[r,n]=(i||"").split("/",2);if(r&&n){let i,a,o,l;try{i=t.fromISO(r,e),a=i.isValid}catch(n){a=!1}try{o=t.fromISO(n,e),l=o.isValid}catch(n){l=!1}if(a&&l)return u.fromDateTimes(i,o);if(a){const t=s.fromISO(n,e);if(t.isValid)return u.after(i,t)}else if(l){const t=s.fromISO(r,e);if(t.isValid)return u.before(o,t)}}return u.invalid("unparsable",`the input "${i}" can't be parsed as ISO 8601`)}static isInterval(t){return t&&t.isLuxonInterval||!1}get start(){return this.isValid?this.s:null}get end(){return this.isValid?this.e:null}get isValid(){return null===this.invalidReason}get invalidReason(){return this.invalid?this.invalid.reason:null}get invalidExplanation(){return this.invalid?this.invalid.explanation:null}length(t="milliseconds"){return this.isValid?this.toDuration(t).get(t):NaN}count(t="milliseconds"){if(!this.isValid)return NaN;const i=this.start.startOf(t),s=this.end.startOf(t);return Math.floor(s.diff(i,t).get(t))+1}hasSame(t){return!!this.isValid&&(this.isEmpty()||this.e.minus(1).hasSame(this.s,t))}isEmpty(){return this.s.valueOf()===this.e.valueOf()}isAfter(t){return!!this.isValid&&this.s>t}isBefore(t){return!!this.isValid&&this.e<=t}contains(t){return!!this.isValid&&(this.s<=t&&this.e>t)}set({start:t,end:i}={}){return this.isValid?u.fromDateTimes(t||this.s,i||this.e):this}splitAt(...t){if(!this.isValid)return[];const s=t.map(i).filter((t=>this.contains(t))).sort(),e=[];let{s:r}=this,n=0;for(;r<this.e;){const t=s[n]||this.e,i=+t>+this.e?this.e:t;e.push(u.fromDateTimes(r,i)),r=i,n+=1}return e}splitBy(t){const i=s.fromDurationLike(t);if(!this.isValid||!i.isValid||0===i.as("milliseconds"))return[];let e,{s:r}=this,n=1;const a=[];for(;r<this.e;){const t=this.start.plus(i.mapUnits((t=>t*n)));e=+t>+this.e?this.e:t,a.push(u.fromDateTimes(r,e)),r=e,n+=1}return a}divideEqually(t){return this.isValid?this.splitBy(this.length()/t).slice(0,t):[]}overlaps(t){return this.e>t.s&&this.s<t.e}abutsStart(t){return!!this.isValid&&+this.e==+t.s}abutsEnd(t){return!!this.isValid&&+t.e==+this.s}engulfs(t){return!!this.isValid&&(this.s<=t.s&&this.e>=t.e)}equals(t){return!(!this.isValid||!t.isValid)&&(this.s.equals(t.s)&&this.e.equals(t.e))}intersection(t){if(!this.isValid)return this;const i=this.s>t.s?this.s:t.s,s=this.e<t.e?this.e:t.e;return i>=s?null:u.fromDateTimes(i,s)}union(t){if(!this.isValid)return this;const i=this.s<t.s?this.s:t.s,s=this.e>t.e?this.e:t.e;return u.fromDateTimes(i,s)}static merge(t){const[i,s]=t.sort(((t,i)=>t.s-i.s)).reduce((([t,i],s)=>i?i.overlaps(s)||i.abutsStart(s)?[t,i.union(s)]:[t.concat([i]),s]:[t,s]),[[],null]);return s&&i.push(s),i}static xor(t){let i=null,s=0;const e=[],r=t.map((t=>[{time:t.s,type:"s"},{time:t.e,type:"e"}])),n=Array.prototype.concat(...r).sort(((t,i)=>t.time-i.time));for(const t of n)s+="s"===t.type?1:-1,1===s?i=t.time:(i&&+i!=+t.time&&e.push(u.fromDateTimes(i,t.time)),i=null);return u.merge(e)}difference(...t){return u.xor([this].concat(t)).map((t=>this.intersection(t))).filter((t=>t&&!t.isEmpty()))}toString(){return this.isValid?`[${this.s.toISO()} – ${this.e.toISO()})`:h}toLocaleString(t=l,i={}){return this.isValid?o.create(this.s.loc.clone(i),t).formatInterval(this):h}toISO(t){return this.isValid?`${this.s.toISO(t)}/${this.e.toISO(t)}`:h}toISODate(){return this.isValid?`${this.s.toISODate()}/${this.e.toISODate()}`:h}toISOTime(t){return this.isValid?`${this.s.toISOTime(t)}/${this.e.toISOTime(t)}`:h}toFormat(t,{separator:i=" – "}={}){return this.isValid?`${this.s.toFormat(t)}${i}${this.e.toFormat(t)}`:h}toDuration(t,i){return this.isValid?this.e.diff(this.s,t,i):s.invalid(this.invalidReason)}mapEndpoints(t){return u.fromDateTimes(t(this.s),t(this.e))}}export{u as default};
//# sourceMappingURL=interval.js.map
