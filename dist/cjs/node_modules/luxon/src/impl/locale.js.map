{"version":3,"file":"locale.js","sources":["../../../../../../node_modules/luxon/src/impl/locale.js"],"sourcesContent":["import { padStart, roundTo, hasRelative } from \"./util.js\";\nimport * as English from \"./english.js\";\nimport Settings from \"../settings.js\";\nimport DateTime from \"../datetime.js\";\nimport IANAZone from \"../zones/IANAZone.js\";\n\n// todo - remap caching\n\nlet intlLFCache = {};\nfunction getCachedLF(locString, opts = {}) {\n  const key = JSON.stringify([locString, opts]);\n  let dtf = intlLFCache[key];\n  if (!dtf) {\n    dtf = new Intl.ListFormat(locString, opts);\n    intlLFCache[key] = dtf;\n  }\n  return dtf;\n}\n\nlet intlDTCache = {};\nfunction getCachedDTF(locString, opts = {}) {\n  const key = JSON.stringify([locString, opts]);\n  let dtf = intlDTCache[key];\n  if (!dtf) {\n    dtf = new Intl.DateTimeFormat(locString, opts);\n    intlDTCache[key] = dtf;\n  }\n  return dtf;\n}\n\nlet intlNumCache = {};\nfunction getCachedINF(locString, opts = {}) {\n  const key = JSON.stringify([locString, opts]);\n  let inf = intlNumCache[key];\n  if (!inf) {\n    inf = new Intl.NumberFormat(locString, opts);\n    intlNumCache[key] = inf;\n  }\n  return inf;\n}\n\nlet intlRelCache = {};\nfunction getCachedRTF(locString, opts = {}) {\n  const { base, ...cacheKeyOpts } = opts; // exclude `base` from the options\n  const key = JSON.stringify([locString, cacheKeyOpts]);\n  let inf = intlRelCache[key];\n  if (!inf) {\n    inf = new Intl.RelativeTimeFormat(locString, opts);\n    intlRelCache[key] = inf;\n  }\n  return inf;\n}\n\nlet sysLocaleCache = null;\nfunction systemLocale() {\n  if (sysLocaleCache) {\n    return sysLocaleCache;\n  } else {\n    sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;\n    return sysLocaleCache;\n  }\n}\n\nfunction parseLocaleString(localeStr) {\n  // I really want to avoid writing a BCP 47 parser\n  // see, e.g. https://github.com/wooorm/bcp-47\n  // Instead, we'll do this:\n\n  // a) if the string has no -u extensions, just leave it alone\n  // b) if it does, use Intl to resolve everything\n  // c) if Intl fails, try again without the -u\n\n  // private subtags and unicode subtags have ordering requirements,\n  // and we're not properly parsing this, so just strip out the\n  // private ones if they exist.\n  const xIndex = localeStr.indexOf(\"-x-\");\n  if (xIndex !== -1) {\n    localeStr = localeStr.substring(0, xIndex);\n  }\n\n  const uIndex = localeStr.indexOf(\"-u-\");\n  if (uIndex === -1) {\n    return [localeStr];\n  } else {\n    let options;\n    let selectedStr;\n    try {\n      options = getCachedDTF(localeStr).resolvedOptions();\n      selectedStr = localeStr;\n    } catch (e) {\n      const smaller = localeStr.substring(0, uIndex);\n      options = getCachedDTF(smaller).resolvedOptions();\n      selectedStr = smaller;\n    }\n\n    const { numberingSystem, calendar } = options;\n    return [selectedStr, numberingSystem, calendar];\n  }\n}\n\nfunction intlConfigString(localeStr, numberingSystem, outputCalendar) {\n  if (outputCalendar || numberingSystem) {\n    if (!localeStr.includes(\"-u-\")) {\n      localeStr += \"-u\";\n    }\n\n    if (outputCalendar) {\n      localeStr += `-ca-${outputCalendar}`;\n    }\n\n    if (numberingSystem) {\n      localeStr += `-nu-${numberingSystem}`;\n    }\n    return localeStr;\n  } else {\n    return localeStr;\n  }\n}\n\nfunction mapMonths(f) {\n  const ms = [];\n  for (let i = 1; i <= 12; i++) {\n    const dt = DateTime.utc(2016, i, 1);\n    ms.push(f(dt));\n  }\n  return ms;\n}\n\nfunction mapWeekdays(f) {\n  const ms = [];\n  for (let i = 1; i <= 7; i++) {\n    const dt = DateTime.utc(2016, 11, 13 + i);\n    ms.push(f(dt));\n  }\n  return ms;\n}\n\nfunction listStuff(loc, length, defaultOK, englishFn, intlFn) {\n  const mode = loc.listingMode(defaultOK);\n\n  if (mode === \"error\") {\n    return null;\n  } else if (mode === \"en\") {\n    return englishFn(length);\n  } else {\n    return intlFn(length);\n  }\n}\n\nfunction supportsFastNumbers(loc) {\n  if (loc.numberingSystem && loc.numberingSystem !== \"latn\") {\n    return false;\n  } else {\n    return (\n      loc.numberingSystem === \"latn\" ||\n      !loc.locale ||\n      loc.locale.startsWith(\"en\") ||\n      new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === \"latn\"\n    );\n  }\n}\n\n/**\n * @private\n */\n\nclass PolyNumberFormatter {\n  constructor(intl, forceSimple, opts) {\n    this.padTo = opts.padTo || 0;\n    this.floor = opts.floor || false;\n\n    const { padTo, floor, ...otherOpts } = opts;\n\n    if (!forceSimple || Object.keys(otherOpts).length > 0) {\n      const intlOpts = { useGrouping: false, ...opts };\n      if (opts.padTo > 0) intlOpts.minimumIntegerDigits = opts.padTo;\n      this.inf = getCachedINF(intl, intlOpts);\n    }\n  }\n\n  format(i) {\n    if (this.inf) {\n      const fixed = this.floor ? Math.floor(i) : i;\n      return this.inf.format(fixed);\n    } else {\n      // to match the browser's numberformatter defaults\n      const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);\n      return padStart(fixed, this.padTo);\n    }\n  }\n}\n\n/**\n * @private\n */\n\nclass PolyDateFormatter {\n  constructor(dt, intl, opts) {\n    this.opts = opts;\n\n    let z = undefined;\n    if (dt.zone.isUniversal) {\n      // UTC-8 or Etc/UTC-8 are not part of tzdata, only Etc/GMT+8 and the like.\n      // That is why fixed-offset TZ is set to that unless it is:\n      // 1. Representing offset 0 when UTC is used to maintain previous behavior and does not become GMT.\n      // 2. Unsupported by the browser:\n      //    - some do not support Etc/\n      //    - < Etc/GMT-14, > Etc/GMT+12, and 30-minute or 45-minute offsets are not part of tzdata\n      const gmtOffset = -1 * (dt.offset / 60);\n      const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;\n      if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {\n        z = offsetZ;\n        this.dt = dt;\n      } else {\n        // Not all fixed-offset zones like Etc/+4:30 are present in tzdata.\n        // So we have to make do. Two cases:\n        // 1. The format options tell us to show the zone. We can't do that, so the best\n        // we can do is format the date in UTC.\n        // 2. The format options don't tell us to show the zone. Then we can adjust them\n        // the time and tell the formatter to show it to us in UTC, so that the time is right\n        // and the bad zone doesn't show up.\n        z = \"UTC\";\n        if (opts.timeZoneName) {\n          this.dt = dt;\n        } else {\n          this.dt = dt.offset === 0 ? dt : DateTime.fromMillis(dt.ts + dt.offset * 60 * 1000);\n        }\n      }\n    } else if (dt.zone.type === \"system\") {\n      this.dt = dt;\n    } else {\n      this.dt = dt;\n      z = dt.zone.name;\n    }\n\n    const intlOpts = { ...this.opts };\n    intlOpts.timeZone = intlOpts.timeZone || z;\n    this.dtf = getCachedDTF(intl, intlOpts);\n  }\n\n  format() {\n    return this.dtf.format(this.dt.toJSDate());\n  }\n\n  formatToParts() {\n    return this.dtf.formatToParts(this.dt.toJSDate());\n  }\n\n  resolvedOptions() {\n    return this.dtf.resolvedOptions();\n  }\n}\n\n/**\n * @private\n */\nclass PolyRelFormatter {\n  constructor(intl, isEnglish, opts) {\n    this.opts = { style: \"long\", ...opts };\n    if (!isEnglish && hasRelative()) {\n      this.rtf = getCachedRTF(intl, opts);\n    }\n  }\n\n  format(count, unit) {\n    if (this.rtf) {\n      return this.rtf.format(count, unit);\n    } else {\n      return English.formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== \"long\");\n    }\n  }\n\n  formatToParts(count, unit) {\n    if (this.rtf) {\n      return this.rtf.formatToParts(count, unit);\n    } else {\n      return [];\n    }\n  }\n}\n\n/**\n * @private\n */\n\nexport default class Locale {\n  static fromOpts(opts) {\n    return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);\n  }\n\n  static create(locale, numberingSystem, outputCalendar, defaultToEN = false) {\n    const specifiedLocale = locale || Settings.defaultLocale;\n    // the system locale is useful for human readable strings but annoying for parsing/formatting known formats\n    const localeR = specifiedLocale || (defaultToEN ? \"en-US\" : systemLocale());\n    const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;\n    const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;\n    return new Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);\n  }\n\n  static resetCache() {\n    sysLocaleCache = null;\n    intlDTCache = {};\n    intlNumCache = {};\n    intlRelCache = {};\n  }\n\n  static fromObject({ locale, numberingSystem, outputCalendar } = {}) {\n    return Locale.create(locale, numberingSystem, outputCalendar);\n  }\n\n  constructor(locale, numbering, outputCalendar, specifiedLocale) {\n    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);\n\n    this.locale = parsedLocale;\n    this.numberingSystem = numbering || parsedNumberingSystem || null;\n    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;\n    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);\n\n    this.weekdaysCache = { format: {}, standalone: {} };\n    this.monthsCache = { format: {}, standalone: {} };\n    this.meridiemCache = null;\n    this.eraCache = {};\n\n    this.specifiedLocale = specifiedLocale;\n    this.fastNumbersCached = null;\n  }\n\n  get fastNumbers() {\n    if (this.fastNumbersCached == null) {\n      this.fastNumbersCached = supportsFastNumbers(this);\n    }\n\n    return this.fastNumbersCached;\n  }\n\n  listingMode() {\n    const isActuallyEn = this.isEnglish();\n    const hasNoWeirdness =\n      (this.numberingSystem === null || this.numberingSystem === \"latn\") &&\n      (this.outputCalendar === null || this.outputCalendar === \"gregory\");\n    return isActuallyEn && hasNoWeirdness ? \"en\" : \"intl\";\n  }\n\n  clone(alts) {\n    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {\n      return this;\n    } else {\n      return Locale.create(\n        alts.locale || this.specifiedLocale,\n        alts.numberingSystem || this.numberingSystem,\n        alts.outputCalendar || this.outputCalendar,\n        alts.defaultToEN || false\n      );\n    }\n  }\n\n  redefaultToEN(alts = {}) {\n    return this.clone({ ...alts, defaultToEN: true });\n  }\n\n  redefaultToSystem(alts = {}) {\n    return this.clone({ ...alts, defaultToEN: false });\n  }\n\n  months(length, format = false, defaultOK = true) {\n    return listStuff(this, length, defaultOK, English.months, () => {\n      const intl = format ? { month: length, day: \"numeric\" } : { month: length },\n        formatStr = format ? \"format\" : \"standalone\";\n      if (!this.monthsCache[formatStr][length]) {\n        this.monthsCache[formatStr][length] = mapMonths((dt) => this.extract(dt, intl, \"month\"));\n      }\n      return this.monthsCache[formatStr][length];\n    });\n  }\n\n  weekdays(length, format = false, defaultOK = true) {\n    return listStuff(this, length, defaultOK, English.weekdays, () => {\n      const intl = format\n          ? { weekday: length, year: \"numeric\", month: \"long\", day: \"numeric\" }\n          : { weekday: length },\n        formatStr = format ? \"format\" : \"standalone\";\n      if (!this.weekdaysCache[formatStr][length]) {\n        this.weekdaysCache[formatStr][length] = mapWeekdays((dt) =>\n          this.extract(dt, intl, \"weekday\")\n        );\n      }\n      return this.weekdaysCache[formatStr][length];\n    });\n  }\n\n  meridiems(defaultOK = true) {\n    return listStuff(\n      this,\n      undefined,\n      defaultOK,\n      () => English.meridiems,\n      () => {\n        // In theory there could be aribitrary day periods. We're gonna assume there are exactly two\n        // for AM and PM. This is probably wrong, but it's makes parsing way easier.\n        if (!this.meridiemCache) {\n          const intl = { hour: \"numeric\", hourCycle: \"h12\" };\n          this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(\n            (dt) => this.extract(dt, intl, \"dayperiod\")\n          );\n        }\n\n        return this.meridiemCache;\n      }\n    );\n  }\n\n  eras(length, defaultOK = true) {\n    return listStuff(this, length, defaultOK, English.eras, () => {\n      const intl = { era: length };\n\n      // This is problematic. Different calendars are going to define eras totally differently. What I need is the minimum set of dates\n      // to definitely enumerate them.\n      if (!this.eraCache[length]) {\n        this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map((dt) =>\n          this.extract(dt, intl, \"era\")\n        );\n      }\n\n      return this.eraCache[length];\n    });\n  }\n\n  extract(dt, intlOpts, field) {\n    const df = this.dtFormatter(dt, intlOpts),\n      results = df.formatToParts(),\n      matching = results.find((m) => m.type.toLowerCase() === field);\n    return matching ? matching.value : null;\n  }\n\n  numberFormatter(opts = {}) {\n    // this forcesimple option is never used (the only caller short-circuits on it, but it seems safer to leave)\n    // (in contrast, the rest of the condition is used heavily)\n    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);\n  }\n\n  dtFormatter(dt, intlOpts = {}) {\n    return new PolyDateFormatter(dt, this.intl, intlOpts);\n  }\n\n  relFormatter(opts = {}) {\n    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);\n  }\n\n  listFormatter(opts = {}) {\n    return getCachedLF(this.intl, opts);\n  }\n\n  isEnglish() {\n    return (\n      this.locale === \"en\" ||\n      this.locale.toLowerCase() === \"en-us\" ||\n      new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith(\"en-us\")\n    );\n  }\n\n  equals(other) {\n    return (\n      this.locale === other.locale &&\n      this.numberingSystem === other.numberingSystem &&\n      this.outputCalendar === other.outputCalendar\n    );\n  }\n}\n"],"names":["intlLFCache","intlDTCache","getCachedDTF","locString","opts","key","JSON","stringify","dtf","Intl","DateTimeFormat","intlNumCache","intlRelCache","sysLocaleCache","listStuff","loc","length","defaultOK","englishFn","intlFn","mode","listingMode","PolyNumberFormatter","constructor","intl","forceSimple","this","padTo","floor","otherOpts","Object","keys","intlOpts","useGrouping","minimumIntegerDigits","inf","NumberFormat","getCachedINF","format","i","fixed","Math","roundTo","padStart","PolyDateFormatter","dt","z","zone","isUniversal","gmtOffset","offset","offsetZ","IANAZone","create","valid","timeZoneName","DateTime","default","fromMillis","ts","type","name","timeZone","toJSDate","formatToParts","resolvedOptions","PolyRelFormatter","isEnglish","style","hasRelative","rtf","base","cacheKeyOpts","RelativeTimeFormat","getCachedRTF","count","unit","English.formatRelativeTime","numeric","Locale","static","locale","numberingSystem","outputCalendar","defaultToEN","specifiedLocale","Settings","defaultLocale","localeR","numberingSystemR","defaultNumberingSystem","outputCalendarR","defaultOutputCalendar","numbering","parsedLocale","parsedNumberingSystem","parsedOutputCalendar","localeStr","xIndex","indexOf","substring","uIndex","options","selectedStr","e","smaller","calendar","parseLocaleString","includes","intlConfigString","weekdaysCache","standalone","monthsCache","meridiemCache","eraCache","fastNumbersCached","fastNumbers","startsWith","isActuallyEn","hasNoWeirdness","clone","alts","getOwnPropertyNames","redefaultToEN","redefaultToSystem","months","English.months","month","day","formatStr","f","ms","utc","push","mapMonths","extract","weekdays","English.weekdays","weekday","year","mapWeekdays","meridiems","undefined","English.meridiems","hour","hourCycle","map","eras","English.eras","era","field","matching","dtFormatter","find","m","toLowerCase","value","numberFormatter","relFormatter","listFormatter","ListFormat","getCachedLF","equals","other"],"mappings":"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"}