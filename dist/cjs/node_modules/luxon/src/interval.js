"use strict";var t=require("./datetime.js"),i=require("./duration.js"),s=require("./settings.js"),e=require("./errors.js"),r=require("./impl/invalid.js"),n=require("./impl/formatter.js"),a=require("./impl/formats.js");const l="Invalid Interval";class o{constructor(t){this.s=t.start,this.e=t.end,this.invalid=t.invalid||null,this.isLuxonInterval=!0}static invalid(t,i=null){if(!t)throw new e.InvalidArgumentError("need to specify a reason the Interval is invalid");const n=t instanceof r?t:new r(t,i);if(s.throwOnInvalid)throw new e.InvalidIntervalError(n);return new o({invalid:n})}static fromDateTimes(i,s){const e=t.friendlyDateTime(i),r=t.friendlyDateTime(s),n=function(t,i){return t&&t.isValid?i&&i.isValid?i<t?o.invalid("end before start",`The end of an interval must be after its start, but you had start=${t.toISO()} and end=${i.toISO()}`):null:o.invalid("missing or invalid end"):o.invalid("missing or invalid start")}(e,r);return null==n?new o({start:e,end:r}):n}static after(s,e){const r=i.default.fromDurationLike(e),n=t.friendlyDateTime(s);return o.fromDateTimes(n,n.plus(r))}static before(s,e){const r=i.default.fromDurationLike(e),n=t.friendlyDateTime(s);return o.fromDateTimes(n.minus(r),n)}static fromISO(s,e){const[r,n]=(s||"").split("/",2);if(r&&n){let s,a,l,h;try{s=t.default.fromISO(r,e),a=s.isValid}catch(n){a=!1}try{l=t.default.fromISO(n,e),h=l.isValid}catch(n){h=!1}if(a&&h)return o.fromDateTimes(s,l);if(a){const t=i.default.fromISO(n,e);if(t.isValid)return o.after(s,t)}else if(h){const t=i.default.fromISO(r,e);if(t.isValid)return o.before(l,t)}}return o.invalid("unparsable",`the input "${s}" can't be parsed as ISO 8601`)}static isInterval(t){return t&&t.isLuxonInterval||!1}get start(){return this.isValid?this.s:null}get end(){return this.isValid?this.e:null}get isValid(){return null===this.invalidReason}get invalidReason(){return this.invalid?this.invalid.reason:null}get invalidExplanation(){return this.invalid?this.invalid.explanation:null}length(t="milliseconds"){return this.isValid?this.toDuration(t).get(t):NaN}count(t="milliseconds"){if(!this.isValid)return NaN;const i=this.start.startOf(t),s=this.end.startOf(t);return Math.floor(s.diff(i,t).get(t))+1}hasSame(t){return!!this.isValid&&(this.isEmpty()||this.e.minus(1).hasSame(this.s,t))}isEmpty(){return this.s.valueOf()===this.e.valueOf()}isAfter(t){return!!this.isValid&&this.s>t}isBefore(t){return!!this.isValid&&this.e<=t}contains(t){return!!this.isValid&&(this.s<=t&&this.e>t)}set({start:t,end:i}={}){return this.isValid?o.fromDateTimes(t||this.s,i||this.e):this}splitAt(...i){if(!this.isValid)return[];const s=i.map(t.friendlyDateTime).filter((t=>this.contains(t))).sort(),e=[];let{s:r}=this,n=0;for(;r<this.e;){const t=s[n]||this.e,i=+t>+this.e?this.e:t;e.push(o.fromDateTimes(r,i)),r=i,n+=1}return e}splitBy(t){const s=i.default.fromDurationLike(t);if(!this.isValid||!s.isValid||0===s.as("milliseconds"))return[];let e,{s:r}=this,n=1;const a=[];for(;r<this.e;){const t=this.start.plus(s.mapUnits((t=>t*n)));e=+t>+this.e?this.e:t,a.push(o.fromDateTimes(r,e)),r=e,n+=1}return a}divideEqually(t){return this.isValid?this.splitBy(this.length()/t).slice(0,t):[]}overlaps(t){return this.e>t.s&&this.s<t.e}abutsStart(t){return!!this.isValid&&+this.e==+t.s}abutsEnd(t){return!!this.isValid&&+t.e==+this.s}engulfs(t){return!!this.isValid&&(this.s<=t.s&&this.e>=t.e)}equals(t){return!(!this.isValid||!t.isValid)&&(this.s.equals(t.s)&&this.e.equals(t.e))}intersection(t){if(!this.isValid)return this;const i=this.s>t.s?this.s:t.s,s=this.e<t.e?this.e:t.e;return i>=s?null:o.fromDateTimes(i,s)}union(t){if(!this.isValid)return this;const i=this.s<t.s?this.s:t.s,s=this.e>t.e?this.e:t.e;return o.fromDateTimes(i,s)}static merge(t){const[i,s]=t.sort(((t,i)=>t.s-i.s)).reduce((([t,i],s)=>i?i.overlaps(s)||i.abutsStart(s)?[t,i.union(s)]:[t.concat([i]),s]:[t,s]),[[],null]);return s&&i.push(s),i}static xor(t){let i=null,s=0;const e=[],r=t.map((t=>[{time:t.s,type:"s"},{time:t.e,type:"e"}])),n=Array.prototype.concat(...r).sort(((t,i)=>t.time-i.time));for(const t of n)s+="s"===t.type?1:-1,1===s?i=t.time:(i&&+i!=+t.time&&e.push(o.fromDateTimes(i,t.time)),i=null);return o.merge(e)}difference(...t){return o.xor([this].concat(t)).map((t=>this.intersection(t))).filter((t=>t&&!t.isEmpty()))}toString(){return this.isValid?`[${this.s.toISO()} – ${this.e.toISO()})`:l}toLocaleString(t=a.DATE_SHORT,i={}){return this.isValid?n.create(this.s.loc.clone(i),t).formatInterval(this):l}toISO(t){return this.isValid?`${this.s.toISO(t)}/${this.e.toISO(t)}`:l}toISODate(){return this.isValid?`${this.s.toISODate()}/${this.e.toISODate()}`:l}toISOTime(t){return this.isValid?`${this.s.toISOTime(t)}/${this.e.toISOTime(t)}`:l}toFormat(t,{separator:i=" – "}={}){return this.isValid?`${this.s.toFormat(t)}${i}${this.e.toFormat(t)}`:l}toDuration(t,s){return this.isValid?this.e.diff(this.s,t,s):i.default.invalid(this.invalidReason)}mapEndpoints(t){return o.fromDateTimes(t(this.s),t(this.e))}}module.exports=o;
//# sourceMappingURL=interval.js.map
