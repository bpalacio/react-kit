{"version":3,"file":"IANAZone.js","sources":["../../../../../../node_modules/luxon/src/zones/IANAZone.js"],"sourcesContent":["import { formatOffset, parseZoneInfo, isUndefined, objToLocalTS } from \"../impl/util.js\";\nimport Zone from \"../zone.js\";\n\nlet dtfCache = {};\nfunction makeDTF(zone) {\n  if (!dtfCache[zone]) {\n    dtfCache[zone] = new Intl.DateTimeFormat(\"en-US\", {\n      hour12: false,\n      timeZone: zone,\n      year: \"numeric\",\n      month: \"2-digit\",\n      day: \"2-digit\",\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n      second: \"2-digit\",\n      era: \"short\",\n    });\n  }\n  return dtfCache[zone];\n}\n\nconst typeToPos = {\n  year: 0,\n  month: 1,\n  day: 2,\n  era: 3,\n  hour: 4,\n  minute: 5,\n  second: 6,\n};\n\nfunction hackyOffset(dtf, date) {\n  const formatted = dtf.format(date).replace(/\\u200E/g, \"\"),\n    parsed = /(\\d+)\\/(\\d+)\\/(\\d+) (AD|BC),? (\\d+):(\\d+):(\\d+)/.exec(formatted),\n    [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;\n  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];\n}\n\nfunction partsOffset(dtf, date) {\n  const formatted = dtf.formatToParts(date);\n  const filled = [];\n  for (let i = 0; i < formatted.length; i++) {\n    const { type, value } = formatted[i];\n    const pos = typeToPos[type];\n\n    if (type === \"era\") {\n      filled[pos] = value;\n    } else if (!isUndefined(pos)) {\n      filled[pos] = parseInt(value, 10);\n    }\n  }\n  return filled;\n}\n\nlet ianaZoneCache = {};\n/**\n * A zone identified by an IANA identifier, like America/New_York\n * @implements {Zone}\n */\nexport default class IANAZone extends Zone {\n  /**\n   * @param {string} name - Zone name\n   * @return {IANAZone}\n   */\n  static create(name) {\n    if (!ianaZoneCache[name]) {\n      ianaZoneCache[name] = new IANAZone(name);\n    }\n    return ianaZoneCache[name];\n  }\n\n  /**\n   * Reset local caches. Should only be necessary in testing scenarios.\n   * @return {void}\n   */\n  static resetCache() {\n    ianaZoneCache = {};\n    dtfCache = {};\n  }\n\n  /**\n   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.\n   * @param {string} s - The string to check validity on\n   * @example IANAZone.isValidSpecifier(\"America/New_York\") //=> true\n   * @example IANAZone.isValidSpecifier(\"Sport~~blorp\") //=> false\n   * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.\n   * @return {boolean}\n   */\n  static isValidSpecifier(s) {\n    return this.isValidZone(s);\n  }\n\n  /**\n   * Returns whether the provided string identifies a real zone\n   * @param {string} zone - The string to check\n   * @example IANAZone.isValidZone(\"America/New_York\") //=> true\n   * @example IANAZone.isValidZone(\"Fantasia/Castle\") //=> false\n   * @example IANAZone.isValidZone(\"Sport~~blorp\") //=> false\n   * @return {boolean}\n   */\n  static isValidZone(zone) {\n    if (!zone) {\n      return false;\n    }\n    try {\n      new Intl.DateTimeFormat(\"en-US\", { timeZone: zone }).format();\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  constructor(name) {\n    super();\n    /** @private **/\n    this.zoneName = name;\n    /** @private **/\n    this.valid = IANAZone.isValidZone(name);\n  }\n\n  /** @override **/\n  get type() {\n    return \"iana\";\n  }\n\n  /** @override **/\n  get name() {\n    return this.zoneName;\n  }\n\n  /** @override **/\n  get isUniversal() {\n    return false;\n  }\n\n  /** @override **/\n  offsetName(ts, { format, locale }) {\n    return parseZoneInfo(ts, format, locale, this.name);\n  }\n\n  /** @override **/\n  formatOffset(ts, format) {\n    return formatOffset(this.offset(ts), format);\n  }\n\n  /** @override **/\n  offset(ts) {\n    const date = new Date(ts);\n\n    if (isNaN(date)) return NaN;\n\n    const dtf = makeDTF(this.name);\n    let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts\n      ? partsOffset(dtf, date)\n      : hackyOffset(dtf, date);\n\n    if (adOrBc === \"BC\") {\n      year = -Math.abs(year) + 1;\n    }\n\n    // because we're using hour12 and https://bugs.chromium.org/p/chromium/issues/detail?id=1025564&can=2&q=%2224%3A00%22%20datetimeformat\n    const adjustedHour = hour === 24 ? 0 : hour;\n\n    const asUTC = objToLocalTS({\n      year,\n      month,\n      day,\n      hour: adjustedHour,\n      minute,\n      second,\n      millisecond: 0,\n    });\n\n    let asTS = +date;\n    const over = asTS % 1000;\n    asTS -= over >= 0 ? over : 1000 + over;\n    return (asUTC - asTS) / (60 * 1000);\n  }\n\n  /** @override **/\n  equals(otherZone) {\n    return otherZone.type === \"iana\" && otherZone.name === this.name;\n  }\n\n  /** @override **/\n  get isValid() {\n    return this.valid;\n  }\n}\n"],"names":["dtfCache","typeToPos","year","month","day","era","hour","minute","second","ianaZoneCache","IANAZone","Zone","static","name","s","this","isValidZone","zone","Intl","DateTimeFormat","timeZone","format","e","constructor","super","zoneName","valid","type","isUniversal","offsetName","ts","locale","parseZoneInfo","formatOffset","offset","date","Date","isNaN","NaN","dtf","hour12","makeDTF","adOrBc","formatToParts","formatted","filled","i","length","value","pos","isUndefined","parseInt","partsOffset","replace","parsed","exec","fMonth","fDay","fYear","fadOrBc","fHour","fMinute","fSecond","hackyOffset","Math","abs","adjustedHour","asTS","over","objToLocalTS","millisecond","equals","otherZone","isValid"],"mappings":"sEAGA,IAAIA,EAAW,CAAA,EAkBf,MAAMC,EAAY,CAChBC,KAAM,EACNC,MAAO,EACPC,IAAK,EACLC,IAAK,EACLC,KAAM,EACNC,OAAQ,EACRC,OAAQ,GA0BV,IAAIC,EAAgB,CAAA,EAKL,MAAMC,UAAiBC,EAKpCC,cAAcC,GAIZ,OAHKJ,EAAcI,KACjBJ,EAAcI,GAAQ,IAAIH,EAASG,IAE9BJ,EAAcI,EACtB,CAMDD,oBACEH,EAAgB,CAAA,EAChBT,EAAW,CAAA,CACZ,CAUDY,wBAAwBE,GACtB,OAAOC,KAAKC,YAAYF,EACzB,CAUDF,mBAAmBK,GACjB,IAAKA,EACH,OAAO,EAET,IAEE,OADA,IAAIC,KAAKC,eAAe,QAAS,CAAEC,SAAUH,IAAQI,UAC9C,CACR,CAAC,MAAOC,GACP,OAAO,CACR,CACF,CAEDC,YAAYV,GACVW,QAEAT,KAAKU,SAAWZ,EAEhBE,KAAKW,MAAQhB,EAASM,YAAYH,EACnC,CAGGc,WACF,MAAO,MACR,CAGGd,WACF,OAAOE,KAAKU,QACb,CAGGG,kBACF,OAAO,CACR,CAGDC,WAAWC,GAAIT,OAAEA,EAAMU,OAAEA,IACvB,OAAOC,EAAAA,cAAcF,EAAIT,EAAQU,EAAQhB,KAAKF,KAC/C,CAGDoB,aAAaH,EAAIT,GACf,OAAOY,EAAAA,aAAalB,KAAKmB,OAAOJ,GAAKT,EACtC,CAGDa,OAAOJ,GACL,MAAMK,EAAO,IAAIC,KAAKN,GAEtB,GAAIO,MAAMF,GAAO,OAAOG,IAExB,MAAMC,EAnJV,SAAiBtB,GAcf,OAbKjB,EAASiB,KACZjB,EAASiB,GAAQ,IAAIC,KAAKC,eAAe,QAAS,CAChDqB,QAAQ,EACRpB,SAAUH,EACVf,KAAM,UACNC,MAAO,UACPC,IAAK,UACLE,KAAM,UACNC,OAAQ,UACRC,OAAQ,UACRH,IAAK,WAGFL,EAASiB,EAClB,CAoIgBwB,CAAQ1B,KAAKF,MACzB,IAAKX,EAAMC,EAAOC,EAAKsC,EAAQpC,EAAMC,EAAQC,GAAU+B,EAAII,cAlH/D,SAAqBJ,EAAKJ,GACxB,MAAMS,EAAYL,EAAII,cAAcR,GAC9BU,EAAS,GACf,IAAK,IAAIC,EAAI,EAAGA,EAAIF,EAAUG,OAAQD,IAAK,CACzC,MAAMnB,KAAEA,EAAIqB,MAAEA,GAAUJ,EAAUE,GAC5BG,EAAMhD,EAAU0B,GAET,QAATA,EACFkB,EAAOI,GAAOD,EACJE,cAAYD,KACtBJ,EAAOI,GAAOE,SAASH,EAAO,IAEjC,CACD,OAAOH,CACT,CAqGQO,CAAYb,EAAKJ,GA1HzB,SAAqBI,EAAKJ,GACxB,MAAMS,EAAYL,EAAIlB,OAAOc,GAAMkB,QAAQ,UAAW,IACpDC,EAAS,kDAAkDC,KAAKX,KAC7DY,EAAQC,EAAMC,EAAOC,EAASC,EAAOC,EAASC,GAAWR,EAC9D,MAAO,CAACI,EAAOF,EAAQC,EAAME,EAASC,EAAOC,EAASC,EACxD,CAsHQC,CAAYxB,EAAKJ,GAEN,OAAXO,IACFxC,EAAyB,EAAjB8D,KAAKC,IAAI/D,IAInB,MAAMgE,EAAwB,KAAT5D,EAAc,EAAIA,EAYvC,IAAI6D,GAAQhC,EACZ,MAAMiC,EAAOD,EAAO,IAEpB,OADAA,GAAQC,GAAQ,EAAIA,EAAO,IAAOA,GAZpBC,EAAAA,aAAa,CACzBnE,OACAC,QACAC,MACAE,KAAM4D,EACN3D,SACAC,SACA8D,YAAa,IAMCH,MACjB,CAGDI,OAAOC,GACL,MAA0B,SAAnBA,EAAU7C,MAAmB6C,EAAU3D,OAASE,KAAKF,IAC7D,CAGG4D,cACF,OAAO1D,KAAKW,KACb"}